import subprocess
from tqdm import tqdm
from multiprocessing import Pool, cpu_count

def apply_command(ip):
    try:
        # Run the command for each IP address
        command = "nmap -Pn {}".format(ip)
        process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True
        )

        # Read the output
        output, error = process.communicate()
        success = process.returncode == 0

        if success:
            return "Command output for {}: {}".format(ip, output.strip())
        else:
            return "Error executing command for {}: {}".format(ip, error.strip())
    except subprocess.CalledProcessError as e:
        # Handle any errors that occur during command execution
        return "Error executing command for {}: {}".format(ip, e)


# Read IP addresses from a file
def read_ip_addresses(filename):
    ip_addresses = []
    with open(filename, "r") as file:
        for line in file:
            ip = line.strip()
            if ip:
                ip_addresses.append(ip)
    return ip_addresses


# Get user input for the IP addresses file
filename = "proxygood"

# Read IP addresses from the file
ip_addresses = read_ip_addresses(filename)

# Number of concurrent processes to use (default to number of CPU cores)
num_processes = cpu_count()

# Apply the command to each IP address using multiprocessing
with Pool(num_processes) as pool, open("nmap/output.txt", "w") as output_file:
    results = list(tqdm(pool.imap(apply_command, ip_addresses), total=len(ip_addresses), desc='Executing commands', unit='command'))

    # Write results to the output file
    for result in results:
        output_file.write(result + "\n")

print("Command execution completed. Results saved in output.txt.")

